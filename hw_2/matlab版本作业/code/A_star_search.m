function path = A_star_search(map,MAX_X,MAX_Y)
%%
%This part is about map/obstacle/and other settings
    %pre-process the grid map, add offset
    size_map = size(map,1);
    Y_offset = 0;
    X_offset = 0;
    
    %Define the 2D grid map array.
    %Obstacle=-1, Target = 0, Start=1
    MAP=2*(ones(MAX_X,MAX_Y));
    
    %Initialize MAP with location of the target
    xval=floor(map(size_map, 1)) + X_offset;
    yval=floor(map(size_map, 2)) + Y_offset;
    xTarget=xval;
    yTarget=yval;
    MAP(xval,yval)=0;
    
    %Initialize MAP with location of the obstacle
    for i = 2: size_map-1
        xval=floor(map(i, 1)) + X_offset;
        yval=floor(map(i, 2)) + Y_offset;
        MAP(xval,yval)=-1;
    end 
    
    %Initialize MAP with location of the start point
    xval=floor(map(1, 1)) + X_offset;
    yval=floor(map(1, 2)) + Y_offset;
    xStart=xval;
    yStart=yval;
    MAP(xval,yval)=1;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %LISTS USED FOR ALGORITHM
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %OPEN LIST STRUCTURE
    %--------------------------------------------------------------------------
    %IS ON LIST 1/0 |X val |Y val |Parent X val |Parent Y val |h(n) |g(n)|f(n)|
    %--------------------------------------------------------------------------
    OPEN=[];
    %CLOSED LIST STRUCTURE
    %--------------
    %X val | Y val |
    %--------------
    % CLOSED=zeros(MAX_VAL,2);
    CLOSED=[];

    %Put all obstacles on the Closed list
    k=1;%Dummy counter
    for i=1:MAX_X
        for j=1:MAX_Y
            if(MAP(i,j) == -1)
                CLOSED(k,1)=i;
                CLOSED(k,2)=j;
                k=k+1;
            end
        end
    end
    CLOSED_COUNT=size(CLOSED,1);
    %set the starting node as the first node
    xNode=xval;
    yNode=yval;
    OPEN_COUNT=1;
    goal_distance=distance(xNode,yNode,xTarget,yTarget);
    path_cost=0;
    OPEN(OPEN_COUNT,:)=insert_open(xNode,yNode,xNode,yNode,goal_distance,path_cost,goal_distance);
    OPEN(OPEN_COUNT,1)=0;
    CLOSED_COUNT=CLOSED_COUNT+1;
    CLOSED(CLOSED_COUNT,1)=xNode;
    CLOSED(CLOSED_COUNT,2)=yNode;
    NoPath=1;

%%
%This part is your homework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% START ALGORITHM
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    OPEN(OPEN_COUNT,1) = 1; % 改为1，不然OPEN队列就为空，while循环直接返回了
    while(1) 
        % 如果OPEN列表为空，返回
        if sum(OPEN(:,1)) == 0
            break;
        end
        % 从OPEN列表中弹出f(n)最低的节点'n'
        i_min = min_fn(OPEN,OPEN_COUNT,xTarget,yTarget); 
        OPEN(i_min,1) = 0; % 弹出
        % 标志节点'n'为expanded
        CLOSED_COUNT = CLOSED_COUNT + 1;
        CLOSED(CLOSED_COUNT,1) = OPEN(i_min,2);
        CLOSED(CLOSED_COUNT,2) = OPEN(i_min,3);
        % 如果节点'n'是目标位置，返回
        if OPEN(i_min,2)==xTarget && OPEN(i_min,3)==yTarget
            NoPath = 0; % 有路辣
            break;
        end
        % 对于所有节点'n'的unexpanded邻节点'm'
        exp_array = expand_array(OPEN(i_min,2),OPEN(i_min,3),OPEN(i_min,7),xTarget,yTarget,CLOSED,MAX_X,MAX_Y);
        if ~isempty(exp_array) % 非空
            for i_m = 1:length(exp_array(:,1)) 
                xNode = exp_array(i_m,1);
                yNode = exp_array(i_m,2);
                hm = exp_array(i_m,3);
                gm = exp_array(i_m,4);
                fm = exp_array(i_m,5);
                if isempty(node_index(OPEN,xNode,yNode)) % 如果邻点不在OPEN列表中 g(m)=infinite？修改了一波原函数，如果不在OPEN列表返回空
                    OPEN_COUNT = OPEN_COUNT + 1;
                    OPEN(OPEN_COUNT,:) = insert_open(xNode,yNode,OPEN(i_min,2),OPEN(i_min,3),hm,gm,fm); % 将邻点push进OPEN列表中
                else
                    index = node_index(OPEN, xNode,yNode); % 获取邻点在OPEN列表的index
                    if OPEN(index,7) > gm % 如果本次expand邻点的cost更小
                        OPEN(index,4) = OPEN(i_min,2); % 修改父节点
                        OPEN(index,5) = OPEN(i_min,3);  
                        OPEN(index,7) = gm; % 更新gm，fm
                        OPEN(index,8) = fm; 
                    end
                end
            end
        end
    end
    
    %Once algorithm has run The optimal path is generated by starting of at the
    %last node(if it is the target node) and then identifying its parent node
    %until it reaches the start node.This is the optimal path
    
    path = [];
    if NoPath == 0
        disp('有路');
        index = node_index(OPEN,xTarget,yTarget);
        n = 1;
        path(n,:) = [xTarget,yTarget];
        while(index ~= 1)
            xval = OPEN(index,4); % 读出当前节点的父节点
            yval = OPEN(index,5);
            index = node_index(OPEN,xval,yval); % 获取父节点的索引
            n = n + 1;
            path(n,:) = [xval,yval]; % 将父节点扔进路径中
        end
        path = flip(path); % 翻转路径
    else
        disp('没路');
    end
    
end
